"use strict";
/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReachingDefTransferFunction = exports.ReachingDefProblem = void 0;
/**
 * Reaching Definitions Data Flow Analysis
 *
 * This module implements the Reaching Definitions data flow analysis algorithm.
 * Reaching Definitions is a forward data flow analysis that determines, for each
 * program point, the set of variable definitions (assignments) that may reach
 * that point without being overwritten.
 *
 * Key Components:
 * 1. **Transfer Function**:
 *    - Computes the out set for each node based on its in set.
 *    - Uses gen and kill sets to model the effects of assignments:
 *      - **gen**: The set of definitions generated by the current node.
 *      - **kill**: The set of definitions killed (overwritten) by the current node.
 *
 * 2. **Meet Operation**:
 *    - Combines data flow values from multiple paths (e.g., union for reaching definitions).
 *    - Ensures that the analysis is conservative (safe) by over-approximating the result.
 *
 *  The analysis is forward, meaning it propagates information from predecessors to successors.
 *
 */
const Stmt_1 = require("../base/Stmt");
const BaseImplicitGraph_1 = require("../graph/BaseImplicitGraph");
const SparseBitVector_1 = require("../../utils/SparseBitVector");
let coCtor = SparseBitVector_1.SparseBitVector;
const BV_SIZE = 32;
class ReachingDefProblem {
    constructor(method, forward = true) {
        this.empty = new coCtor(BV_SIZE);
        this.flowGraph = new ReachingDefFlowGraph(method);
        this.transferFunction = new ReachingDefTransferFunction(this.flowGraph);
        this.meet = (x, y) => {
            let r = x.clone();
            r.unionWith(y);
            return r;
        };
        this.initIn = new Map(this.flowGraph.nodesInPostOrder.map(i => [i, new coCtor(BV_SIZE)]));
        this.initOut = new Map(this.flowGraph.nodesInPostOrder.map(i => [i, new coCtor(BV_SIZE)]));
        this.forward = forward;
    }
}
exports.ReachingDefProblem = ReachingDefProblem;
/**
 * Represents the control flow graph (CFG) for reaching definitions analysis.
 * This class implements the FlowGraph interface and provides methods to retrieve
 * successors and predecessors of nodes, as well as topological orderings of nodes.
 */
class ReachingDefFlowGraph extends BaseImplicitGraph_1.BaseImplicitGraph {
    constructor(method) {
        super();
        const cfg = method.getCfg();
        if (!cfg) {
            throw new Error('CFG not found');
        }
        const nodes = cfg.getStmts();
        this.nodeToIdMap = new Map(nodes.map((x, i) => [x, i]));
        this.idToNodeMap = new Map(nodes.map((x, i) => [i, x]));
        this.nodesInPostOrder = nodes.map((_, i) => i);
        this.initSuccPred(nodes, cfg);
    }
    getGraphName() {
        return 'Reaching Definition Flow Graph';
    }
    dumpNodes() {
        var _a;
        (_a = this.nodeToIdMap) === null || _a === void 0 ? void 0 : _a.forEach((id, node) => console.log(id + ': ' + node.toString()));
    }
    initSuccPred(nodes, cfg) {
        this.succMap = new Map();
        this.predMap = new Map();
        cfg.getBlocks().forEach(bb => {
            let stmts = bb.getStmts();
            if (stmts.length === 0) {
                return;
            }
            for (let i = 0; i < stmts.length - 1; i++) {
                let c = this.nodeToIdMap.get(stmts[i]);
                let n = this.nodeToIdMap.get(stmts[i + 1]);
                if (c === undefined || n === undefined) {
                    continue;
                }
                this.succMap.set(c, [n]);
                this.predMap.set(n, [c]);
            }
            let terminate = bb.getTail();
            if (!terminate) {
                throw new Error('cfg has no terminal');
            }
            let successors = bb.getSuccessors();
            // try...catch语句，catch所在的block在CFG表示里是没有前驱block的，需要在这里额外查找并将exceptionalSuccessorBlocks作为try块的后继块之一
            const exceptionalSuccessorBlocks = bb.getExceptionalSuccessorBlocks();
            if (exceptionalSuccessorBlocks !== undefined) {
                successors.push(...exceptionalSuccessorBlocks);
            }
            successors.forEach(succBB => {
                var _a, _b, _c, _d;
                let head = succBB.getHead();
                if (!head) {
                    return;
                }
                let t = (_a = this.nodeToIdMap) === null || _a === void 0 ? void 0 : _a.get(terminate);
                let h = (_b = this.nodeToIdMap) === null || _b === void 0 ? void 0 : _b.get(head);
                if (t === undefined || h === undefined) {
                    return;
                }
                // Terminate's succ
                let succ = (_c = this.succMap.get(t)) !== null && _c !== void 0 ? _c : [];
                succ.push(h);
                this.succMap.set(t, succ);
                // Head's pred
                let pred = (_d = this.predMap.get(h)) !== null && _d !== void 0 ? _d : [];
                pred.push(t);
                this.predMap.set(h, pred);
            });
        });
    }
}
/**
 * Represents the transfer function for reaching definitions analysis.
 */
class ReachingDefTransferFunction {
    constructor(flowGraph) {
        this.gen = new coCtor(BV_SIZE);
        this.kill = new Map();
        this.initGenKill(flowGraph);
    }
    apply(n, x) {
        const result = x.clone();
        if (this.gen.test(n)) {
            result.set(n);
        }
        const killSet = this.kill.get(n);
        if (killSet) {
            for (const item of killSet) {
                result.reset(item);
            }
        }
        return result;
    }
    initGenKill(g) {
        let genValue2Nodes = new Map();
        // Init Gen
        g.getNodeToIdMap().forEach((id, node) => {
            var _a;
            if (node instanceof Stmt_1.ArkAssignStmt) {
                let lop = node.getLeftOp();
                let genNodes = (_a = genValue2Nodes.get(lop)) !== null && _a !== void 0 ? _a : new coCtor(BV_SIZE);
                genNodes.set(id);
                genValue2Nodes.set(lop, genNodes);
                this.gen.set(id);
            }
        });
        // Init Kill
        genValue2Nodes.forEach((defNodes, v) => {
            for (const i of defNodes) {
                const killSet = defNodes.clone();
                killSet.reset(i);
                this.kill.set(i, killSet);
            }
        });
    }
}
exports.ReachingDefTransferFunction = ReachingDefTransferFunction;
