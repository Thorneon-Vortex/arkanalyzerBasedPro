"use strict";
/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initModulePathMap = exports.findArkExportInFile = exports.findArkExport = exports.findExportInfo = exports.getArkFile = exports.ModelUtils = void 0;
const Local_1 = require("../base/Local");
const ArkClass_1 = require("../model/ArkClass");
const ArkFile_1 = require("../model/ArkFile");
const ArkMethod_1 = require("../model/ArkMethod");
const ArkNamespace_1 = require("../model/ArkNamespace");
const ArkSignature_1 = require("../model/ArkSignature");
const ArkExport_1 = require("../model/ArkExport");
const ArkField_1 = require("../model/ArkField");
const logger_1 = __importStar(require("../../utils/logger"));
const FileUtils_1 = require("../../utils/FileUtils");
const path_1 = __importDefault(require("path"));
const TSConst_1 = require("./TSConst");
const ArkExportBuilder_1 = require("../model/builder/ArkExportBuilder");
const Type_1 = require("../base/Type");
const Const_1 = require("./Const");
const ValueUtil_1 = require("./ValueUtil");
const Stmt_1 = require("../base/Stmt");
const Ref_1 = require("../base/Ref");
const SdkUtils_1 = require("./SdkUtils");
const TypeInference_1 = require("./TypeInference");
class ModelUtils {
    /*
     * Set static field to be null, then all related objects could be freed by GC.
     * Static field implicitArkUIBuilderMethods is only used during method body building, the dispose method should be called after build all body.
     */
    static dispose() {
        this.implicitArkUIBuilderMethods.clear();
    }
    static getMethodSignatureFromArkClass(arkClass, methodName) {
        for (const arkMethod of arkClass.getMethods()) {
            if (arkMethod.getName() === methodName) {
                return arkMethod.getSignature();
            }
        }
        return null;
    }
    static getClassWithNameInNamespaceRecursively(className, ns) {
        if (className === '') {
            return null;
        }
        let res = null;
        res = ns.getClassWithName(className);
        if (res == null) {
            let declaringNs = ns.getDeclaringArkNamespace();
            if (declaringNs != null) {
                res = this.getClassWithNameInNamespaceRecursively(className, declaringNs);
            }
            else {
                res = this.getClassInFileWithName(className, ns.getDeclaringArkFile());
            }
        }
        return res;
    }
    static getClassWithNameFromClass(className, startFrom) {
        if (!className.includes('.')) {
            let res = null;
            const arkNamespace = startFrom.getDeclaringArkNamespace();
            if (arkNamespace) {
                res = this.getClassWithNameInNamespaceRecursively(className, arkNamespace);
            }
            else {
                res = this.getClassInFileWithName(className, startFrom.getDeclaringArkFile());
            }
            return res;
        }
        else {
            const names = className.split('.');
            let nameSpace = this.getNamespaceWithNameFromClass(names[0], startFrom);
            for (let i = 1; i < names.length - 1; i++) {
                if (nameSpace) {
                    nameSpace = nameSpace.getNamespaceWithName(names[i]);
                }
            }
            if (nameSpace) {
                return nameSpace.getClassWithName(names[names.length - 1]);
            }
        }
        return null;
    }
    /**
     *  search class within the file that contain the given method
     */
    static getClassWithName(className, thisClass) {
        var _a;
        if (thisClass.getName() === className) {
            return thisClass;
        }
        let classSearched = (_a = thisClass.getDeclaringArkNamespace()) === null || _a === void 0 ? void 0 : _a.getClassWithName(className);
        if (!classSearched) {
            classSearched = thisClass.getDeclaringArkFile().getClassWithName(className);
        }
        return classSearched;
    }
    /** search class within the given file */
    static getClassInFileWithName(className, arkFile) {
        let classSearched = arkFile.getClassWithName(className);
        if (classSearched != null) {
            return classSearched;
        }
        return null;
    }
    static getClassInImportInfoWithName(className, arkFile) {
        let arkExport = this.getArkExportInImportInfoWithName(className, arkFile);
        if (arkExport instanceof ArkClass_1.ArkClass) {
            return arkExport;
        }
        return null;
    }
    /** search type within the given file import infos */
    static getArkExportInImportInfoWithName(name, arkFile) {
        var _a, _b, _c;
        return (_c = (_b = (_a = arkFile.getImportInfoBy(name)) === null || _a === void 0 ? void 0 : _a.getLazyExportInfo()) === null || _b === void 0 ? void 0 : _b.getArkExport()) !== null && _c !== void 0 ? _c : null;
    }
    /** search method within the file that contain the given method */
    static getMethodWithName(methodName, startFrom) {
        if (!methodName.includes('.')) {
            if (startFrom.getName() === methodName) {
                return startFrom;
            }
            const thisClass = startFrom.getDeclaringArkClass();
            let methodSearched = thisClass.getMethodWithName(methodName);
            if (!methodSearched) {
                methodSearched = thisClass.getStaticMethodWithName(methodName);
            }
            return methodSearched;
        }
        else {
            const names = methodName.split('.');
            let nameSpace = this.getNamespaceWithName(names[0], startFrom.getDeclaringArkClass());
            for (let i = 1; i < names.length - 1; i++) {
                if (nameSpace) {
                    nameSpace = nameSpace.getNamespaceWithName(names[i]);
                }
            }
            if (nameSpace) {
                return nameSpace.getDefaultClass().getMethodWithName(names[names.length - 1]);
            }
        }
        return null;
    }
    static getNamespaceWithNameFromClass(namespaceName, startFrom) {
        const thisNamespace = startFrom.getDeclaringArkNamespace();
        let namespaceSearched = null;
        if (thisNamespace) {
            namespaceSearched = thisNamespace.getNamespaceWithName(namespaceName);
            if (namespaceSearched) {
                return namespaceSearched;
            }
        }
        const thisFile = startFrom.getDeclaringArkFile();
        namespaceSearched = this.getNamespaceInFileWithName(namespaceName, thisFile);
        return namespaceSearched;
    }
    static getNamespaceWithName(namespaceName, thisClass) {
        let thisNamespace = thisClass.getDeclaringArkNamespace();
        let namespaceSearched = null;
        while (!namespaceSearched && thisNamespace) {
            namespaceSearched = thisNamespace.getNamespaceWithName(namespaceName);
            thisNamespace = thisNamespace.getDeclaringArkNamespace();
        }
        if (!namespaceSearched) {
            namespaceSearched = thisClass.getDeclaringArkFile().getNamespaceWithName(namespaceName);
        }
        return namespaceSearched;
    }
    static getNamespaceInFileWithName(namespaceName, arkFile) {
        let namespaceSearched = arkFile.getNamespaceWithName(namespaceName);
        if (namespaceSearched) {
            return namespaceSearched;
        }
        return null;
    }
    static findSymbolInFileWithName(symbolName, arkClass, onlyType = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        // find symbol from enum value
        if (arkClass.getCategory() === ArkClass_1.ClassCategory.ENUM) {
            const field = arkClass.getStaticFieldWithName(symbolName);
            if (field) {
                return new Local_1.Local(symbolName, (_a = TypeInference_1.TypeInference.getEnumValueType(field)) !== null && _a !== void 0 ? _a : field.getType());
            }
        }
        // look up symbol from inner to outer
        let currNamespace = arkClass.getDeclaringArkNamespace();
        let result;
        while (currNamespace) {
            result = (_f = (_b = currNamespace.getClassWithName(symbolName)) !== null && _b !== void 0 ? _b : (_e = (_d = (_c = currNamespace.getDefaultClass()) === null || _c === void 0 ? void 0 : _c.getDefaultArkMethod()) === null || _d === void 0 ? void 0 : _d.getBody()) === null || _e === void 0 ? void 0 : _e.getAliasTypeByName(symbolName)) !== null && _f !== void 0 ? _f : (_k = (_j = (_h = (_g = currNamespace.getDefaultClass()) === null || _g === void 0 ? void 0 : _g.getDefaultArkMethod()) === null || _h === void 0 ? void 0 : _h.getBody()) === null || _j === void 0 ? void 0 : _j.getLocals()) === null || _k === void 0 ? void 0 : _k.get(symbolName);
            if (!result && !onlyType) {
                result = (_m = (_l = (currNamespace.getName() === symbolName ? currNamespace : null)) !== null && _l !== void 0 ? _l : currNamespace.getNamespaceWithName(symbolName)) !== null && _m !== void 0 ? _m : currNamespace.getDefaultClass().getMethodWithName(symbolName);
            }
            if (result) {
                return result;
            }
            currNamespace = currNamespace.getDeclaringArkNamespace();
        }
        const file = arkClass.getDeclaringArkFile();
        result =
            (_r = (_o = file.getClassWithName(symbolName)) !== null && _o !== void 0 ? _o : (_q = (_p = file.getDefaultClass().getDefaultArkMethod()) === null || _p === void 0 ? void 0 : _p.getBody()) === null || _q === void 0 ? void 0 : _q.getAliasTypeByName(symbolName)) !== null && _r !== void 0 ? _r : (_u = (_t = (_s = file.getDefaultClass()) === null || _s === void 0 ? void 0 : _s.getDefaultArkMethod()) === null || _t === void 0 ? void 0 : _t.getBody()) === null || _u === void 0 ? void 0 : _u.getLocals().get(symbolName);
        if (!result && !onlyType) {
            result = (_v = file.getNamespaceWithName(symbolName)) !== null && _v !== void 0 ? _v : file.getDefaultClass().getMethodWithName(symbolName);
        }
        return result || null;
    }
    static getNamespaceInImportInfoWithName(namespaceName, arkFile) {
        let arkExport = this.getArkExportInImportInfoWithName(namespaceName, arkFile);
        if (arkExport instanceof ArkNamespace_1.ArkNamespace) {
            return arkExport;
        }
        return null;
    }
    static getStaticMethodWithName(methodName, thisClass) {
        const thisNamespace = thisClass.getDeclaringArkNamespace();
        if (thisNamespace) {
            const defaultClass = thisNamespace.getClassWithName(Const_1.DEFAULT_ARK_CLASS_NAME);
            if (defaultClass) {
                const method = defaultClass.getMethodWithName(methodName);
                if (method) {
                    return method;
                }
            }
        }
        return this.getStaticMethodInFileWithName(methodName, thisClass.getDeclaringArkFile());
    }
    static isLanguageOverloadSupport(language) {
        if (language === ArkFile_1.Language.CXX) {
            return true;
        }
        else {
            return false;
        }
    }
    static getStaticMethodInFileWithName(methodName, arkFile) {
        const defaultClass = arkFile.getClasses().find(cls => cls.getName() === Const_1.DEFAULT_ARK_CLASS_NAME) || null;
        if (defaultClass) {
            let method = defaultClass.getMethodWithName(methodName);
            if (method) {
                return method;
            }
        }
        return null;
    }
    static getStaticMethodInImportInfoWithName(methodName, arkFile) {
        let arkExport = this.getArkExportInImportInfoWithName(methodName, arkFile);
        if (arkExport instanceof ArkMethod_1.ArkMethod) {
            return arkExport;
        }
        return null;
    }
    static getLocalInImportInfoWithName(localName, arkFile) {
        let arkExport = this.getArkExportInImportInfoWithName(localName, arkFile);
        if (arkExport instanceof Local_1.Local) {
            return arkExport;
        }
        return null;
    }
    /* get nested namespaces in a file */
    static getAllNamespacesInFile(arkFile) {
        const arkNamespaces = arkFile.getNamespaces();
        for (const arkNamespace of arkFile.getNamespaces()) {
            this.getAllNamespacesInNamespace(arkNamespace, arkNamespaces);
        }
        return arkNamespaces;
    }
    /* get nested namespaces in a namespace */
    static getAllNamespacesInNamespace(arkNamespace, allNamespaces) {
        allNamespaces.push(...arkNamespace.getNamespaces());
        for (const nestedNamespace of arkNamespace.getNamespaces()) {
            this.getAllNamespacesInNamespace(nestedNamespace, allNamespaces);
        }
    }
    static getAllClassesInFile(arkFile) {
        const allClasses = arkFile.getClasses();
        this.getAllNamespacesInFile(arkFile).forEach(namespace => {
            allClasses.push(...namespace.getClasses());
        });
        return allClasses;
    }
    static getAllMethodsInFile(arkFile) {
        const allMethods = [];
        this.getAllClassesInFile(arkFile).forEach(cls => {
            allMethods.push(...cls.getMethods());
        });
        return allMethods;
    }
    static isArkUIBuilderMethod(arkMethod) {
        let isArkUIBuilderMethod = arkMethod.hasBuilderDecorator() || this.implicitArkUIBuilderMethods.has(arkMethod);
        if (!isArkUIBuilderMethod && arkMethod.getName() === 'build' && arkMethod.getDeclaringArkClass().hasComponentDecorator() && !arkMethod.isStatic()) {
            const fileName = arkMethod.getDeclaringArkClass().getDeclaringArkFile().getName();
            if (fileName.endsWith('.ets')) {
                isArkUIBuilderMethod = true;
            }
        }
        return isArkUIBuilderMethod;
    }
    static getArkClassInBuild(scene, classType) {
        var _a;
        const classSignature = classType.getClassSignature();
        const file = scene.getFile(classSignature.getDeclaringFileSignature());
        const namespaceSignature = classSignature.getDeclaringNamespaceSignature();
        if (namespaceSignature) {
            return ((_a = file === null || file === void 0 ? void 0 : file.getNamespace(namespaceSignature)) === null || _a === void 0 ? void 0 : _a.getClass(classSignature)) || null;
        }
        return (file === null || file === void 0 ? void 0 : file.getClassWithName(classSignature.getClassName())) || null;
    }
    static getDefaultClass(arkClass) {
        var _a, _b;
        return (_b = (_a = arkClass.getDeclaringArkNamespace()) === null || _a === void 0 ? void 0 : _a.getDefaultClass()) !== null && _b !== void 0 ? _b : arkClass.getDeclaringArkFile().getDefaultClass();
    }
    static getClass(method, signature) {
        var _a;
        let cls = method.getDeclaringArkFile().getScene().getClass(signature);
        if (cls) {
            return cls;
        }
        let importInfo = method.getDeclaringArkFile().getImportInfoBy(signature.getClassName());
        let exportInfo = importInfo ? findExportInfo(importInfo) : null;
        let arkExport = exportInfo === null || exportInfo === void 0 ? void 0 : exportInfo.getArkExport();
        if (arkExport instanceof ArkClass_1.ArkClass) {
            return arkExport;
        }
        cls = (_a = method.getDeclaringArkClass().getDeclaringArkNamespace()) === null || _a === void 0 ? void 0 : _a.getClassWithName(signature.getClassName());
        if (cls) {
            return cls;
        }
        for (const ns of method.getDeclaringArkFile().getAllNamespacesUnderThisFile()) {
            cls = ns.getClassWithName(signature.getClassName());
            if (cls) {
                return cls;
            }
        }
        return method.getDeclaringArkFile().getClassWithName(signature.getClassName());
    }
    static findPropertyInNamespace(name, namespace) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        return ((_j = (_e = (_d = (_c = (_b = (_a = namespace.getDefaultClass()) === null || _a === void 0 ? void 0 : _a.getMethodWithName(name)) !== null && _b !== void 0 ? _b : findArkExport(namespace.getExportInfoBy(name))) !== null && _c !== void 0 ? _c : namespace.getClassWithName(name)) !== null && _d !== void 0 ? _d : namespace.getNamespaceWithName(name)) !== null && _e !== void 0 ? _e : (_h = (_g = (_f = namespace.getDefaultClass()) === null || _f === void 0 ? void 0 : _f.getDefaultArkMethod()) === null || _g === void 0 ? void 0 : _g.getBody()) === null || _h === void 0 ? void 0 : _h.getAliasTypeByName(name)) !== null && _j !== void 0 ? _j : (_o = (_m = (_l = (_k = namespace.getDefaultClass()) === null || _k === void 0 ? void 0 : _k.getDefaultArkMethod()) === null || _l === void 0 ? void 0 : _l.getBody()) === null || _m === void 0 ? void 0 : _m.getLocals()) === null || _o === void 0 ? void 0 : _o.get(name));
    }
    static findPropertyInClass(name, arkClass) {
        var _a, _b, _c;
        let property = (_c = (_b = (_a = arkClass.getMethodWithName(name)) !== null && _a !== void 0 ? _a : arkClass.getStaticMethodWithName(name)) !== null && _b !== void 0 ? _b : arkClass.getFieldWithName(name)) !== null && _c !== void 0 ? _c : arkClass.getStaticFieldWithName(name);
        if (property) {
            return property;
        }
        if (arkClass.isDefaultArkClass()) {
            return findArkExport(arkClass.getDeclaringArkFile().getExportInfoBy(name));
        }
        for (const heritage of arkClass.getAllHeritageClasses()) {
            property = this.findPropertyInClass(name, heritage);
            if (property) {
                return property;
            }
        }
        return null;
    }
    static findDeclaredLocal(local, arkMethod, times = 0) {
        var _a, _b;
        if (arkMethod.getDeclaringArkFile().getScene().getOptions().isScanAbc) {
            return null;
        }
        const name = local.getName();
        if (name === TSConst_1.THIS_NAME || name.startsWith(Const_1.TEMP_LOCAL_PREFIX)) {
            return null;
        }
        const parameter = arkMethod.getParameters().find(p => p.getName() === name);
        if (parameter) {
            return new Local_1.Local(parameter.getName(), parameter.getType());
        }
        if (times > 0) {
            const declaredLocal = (_a = arkMethod.getBody()) === null || _a === void 0 ? void 0 : _a.getLocals().get(name);
            if (declaredLocal &&
                declaredLocal.getDeclaringStmt() instanceof Stmt_1.ArkAssignStmt &&
                !(declaredLocal.getDeclaringStmt().getRightOp() instanceof Ref_1.ClosureFieldRef)) {
                return declaredLocal;
            }
        }
        let parentName = arkMethod.getName();
        if (parentName === Const_1.DEFAULT_ARK_METHOD_NAME) {
            return null;
        }
        let invokeMethod = arkMethod.getOuterMethod();
        if (!invokeMethod) {
            const className = arkMethod.getDeclaringArkClass().getName();
            const outerStart = className.indexOf(Const_1.NAME_DELIMITER);
            const outerEnd = className.lastIndexOf('.');
            if (outerStart > -1 && outerEnd > -1) {
                invokeMethod = (_b = arkMethod
                    .getDeclaringArkFile()
                    .getClassWithName(className.substring(outerStart + 1, outerEnd))) === null || _b === void 0 ? void 0 : _b.getMethodWithName(className.substring(outerEnd + 1));
            }
            else {
                const symbol = this.findSymbolInFileWithName(name, arkMethod.getDeclaringArkClass(), true);
                return symbol instanceof Local_1.Local ? symbol : null;
            }
        }
        if (invokeMethod) {
            return this.findDeclaredLocal(local, invokeMethod, ++times);
        }
        return null;
    }
    static findArkModel(baseName, arkClass) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        let arkModel = (_c = (_b = (_a = arkClass.getMethodWithName(baseName)) !== null && _a !== void 0 ? _a : arkClass.getStaticMethodWithName(baseName)) !== null && _b !== void 0 ? _b : arkClass.getFieldWithName(baseName)) !== null && _c !== void 0 ? _c : arkClass.getStaticFieldWithName(baseName);
        if (arkModel) {
            return arkModel;
        }
        arkModel =
            (_r = (_m = (_k = (_j = (_h = (_g = (_f = (_e = (_d = ModelUtils.getDefaultClass(arkClass)) === null || _d === void 0 ? void 0 : _d.getDefaultArkMethod()) === null || _e === void 0 ? void 0 : _e.getBody()) === null || _f === void 0 ? void 0 : _f.getLocals()) === null || _g === void 0 ? void 0 : _g.get(baseName)) !== null && _h !== void 0 ? _h : ModelUtils.getClassWithName(baseName, arkClass)) !== null && _j !== void 0 ? _j : ModelUtils.getNamespaceWithName(baseName, arkClass)) !== null && _k !== void 0 ? _k : (_l = ModelUtils.getDefaultClass(arkClass)) === null || _l === void 0 ? void 0 : _l.getMethodWithName(baseName)) !== null && _m !== void 0 ? _m : (_q = (_p = (_o = ModelUtils.getDefaultClass(arkClass)) === null || _o === void 0 ? void 0 : _o.getDefaultArkMethod()) === null || _p === void 0 ? void 0 : _p.getBody()) === null || _q === void 0 ? void 0 : _q.getAliasTypeByName(baseName)) !== null && _r !== void 0 ? _r : ModelUtils.getArkExportInImportInfoWithName(baseName, arkClass.getDeclaringArkFile());
        if (!arkModel && !arkClass.getDeclaringArkFile().getImportInfoBy(baseName)) {
            arkModel = arkClass.getDeclaringArkFile().getScene().getSdkGlobal(baseName);
        }
        return arkModel;
    }
    static findGlobalRef(refName, method) {
        var _a, _b;
        return ((_b = (_a = this.findDeclaredLocal(new Local_1.Local(refName), method, 1)) !== null && _a !== void 0 ? _a : this.getArkExportInImportInfoWithName(refName, method.getDeclaringArkFile())) !== null && _b !== void 0 ? _b : method.getDeclaringArkFile().getScene().getSdkGlobal(refName));
    }
    static findArkModelByRefName(refName, arkClass) {
        const singleNames = refName.split('.');
        let model = null;
        for (let i = 0; i < singleNames.length; i++) {
            if (model instanceof Local_1.Local || model instanceof ArkField_1.ArkField) {
                const type = model.getType();
                if (type instanceof Type_1.ClassType) {
                    model = arkClass.getDeclaringArkFile().getScene().getClass(type.getClassSignature());
                }
                else if (type instanceof Type_1.AnnotationNamespaceType) {
                    model = arkClass.getDeclaringArkFile().getScene().getNamespace(type.getNamespaceSignature());
                }
            }
            const name = singleNames[i].replace(/<(\w+)>/, ValueUtil_1.EMPTY_STRING);
            if (i === 0) {
                model = this.findArkModel(name, arkClass);
            }
            else if (model instanceof ArkClass_1.ArkClass) {
                model = this.findPropertyInClass(name, model);
            }
            else if (model instanceof ArkNamespace_1.ArkNamespace) {
                model = this.findPropertyInNamespace(name, model);
            }
            if (!model) {
                return null;
            }
        }
        return model;
    }
    static findArkModelBySignature(signature, scene) {
        var _a, _b, _c, _d, _e, _f;
        if (signature instanceof ArkSignature_1.ClassSignature) {
            return scene.getClass(signature);
        }
        else if (signature instanceof ArkSignature_1.NamespaceSignature) {
            return scene.getNamespace(signature);
        }
        else if (signature instanceof ArkSignature_1.MethodSignature) {
            return scene.getMethod(signature);
        }
        else if (signature instanceof ArkSignature_1.FieldSignature) {
            const declare = this.findArkModelBySignature(signature.getDeclaringSignature(), scene);
            if (declare instanceof ArkClass_1.ArkClass) {
                return this.findPropertyInClass(signature.getFieldName(), declare);
            }
            else if (declare instanceof ArkNamespace_1.ArkNamespace) {
                return this.findPropertyInNamespace(signature.getFieldName(), declare) || null;
            }
            return null;
        }
        else if (signature instanceof ArkSignature_1.LocalSignature) {
            const declare = scene.getMethod(signature.getDeclaringMethodSignature());
            return (_d = (_b = (_a = declare === null || declare === void 0 ? void 0 : declare.getBody()) === null || _a === void 0 ? void 0 : _a.getLocals().get(signature.getName())) !== null && _b !== void 0 ? _b : (_c = declare === null || declare === void 0 ? void 0 : declare.getBody()) === null || _c === void 0 ? void 0 : _c.getAliasTypeByName(signature.getName())) !== null && _d !== void 0 ? _d : null;
        }
        else if (signature instanceof ArkSignature_1.AliasTypeSignature) {
            const declare = scene.getMethod(signature.getDeclaringMethodSignature());
            return (_f = (_e = declare === null || declare === void 0 ? void 0 : declare.getBody()) === null || _e === void 0 ? void 0 : _e.getAliasTypeByName(signature.getName())) !== null && _f !== void 0 ? _f : null;
        }
        return null;
    }
    static parseArkBaseModel2Type(arkBaseModel) {
        if (arkBaseModel instanceof ArkClass_1.ArkClass) {
            return new Type_1.ClassType(arkBaseModel.getSignature(), arkBaseModel.getGenericsTypes());
        }
        else if (arkBaseModel instanceof ArkNamespace_1.ArkNamespace) {
            return Type_1.AnnotationNamespaceType.getInstance(arkBaseModel.getSignature());
        }
        else if (arkBaseModel instanceof ArkMethod_1.ArkMethod) {
            return new Type_1.FunctionType(arkBaseModel.getSignature());
        }
        else if (arkBaseModel instanceof ArkField_1.ArkField) {
            if (arkBaseModel.getType() instanceof Type_1.UnknownType || arkBaseModel.getType() instanceof Type_1.UnclearReferenceType) {
                return null;
            }
            return arkBaseModel.getType();
        }
        return null;
    }
}
exports.ModelUtils = ModelUtils;
ModelUtils.implicitArkUIBuilderMethods = new Set();
const logger = logger_1.default.getLogger(logger_1.LOG_MODULE_TYPE.ARKANALYZER, 'ModelUtils');
let moduleMap;
/**
 * find arkFile by from info
 * export xx from '../xx'
 * import xx from '@ohos/xx'
 * import xx from '@ohos.xx'
 * @param im importInfo or exportInfo
 */
function getArkFile(im) {
    const from = im.getFrom();
    if (!from) {
        return null;
    }
    if (/^([^@]*\/)([^\/]*)$/.test(from)) {
        //relative path
        const parentPath = /^\.{1,2}\//.test(from) ? path_1.default.dirname(im.getDeclaringArkFile().getFilePath()) : im.getDeclaringArkFile().getProjectDir();
        const originPath = path_1.default.resolve(parentPath, from);
        return getArkFileFromScene(im, originPath);
    }
    else if ((moduleMap === null || moduleMap === void 0 ? void 0 : moduleMap.get(from)) || /^@[a-z|\-]+?\//.test(from)) {
        //module path
        const arkFile = getArkFileFromOtherModule(im);
        if (arkFile) {
            return arkFile;
        }
    }
    //sdk path
    const file = SdkUtils_1.SdkUtils.getImportSdkFile(from);
    if (file) {
        return file;
    }
    const scene = im.getDeclaringArkFile().getScene();
    for (const sdk of scene.getProjectSdkMap().values()) {
        const arkFile = getArkFileFormMap(sdk.name, processSdkPath(sdk, from), scene);
        if (arkFile) {
            return arkFile;
        }
    }
    return null;
}
exports.getArkFile = getArkFile;
/**
 * find from info's export
 * @param fromInfo importInfo or exportInfo
 */
function findExportInfo(fromInfo) {
    var _a, _b;
    let file = getArkFile(fromInfo);
    if (!file) {
        logger.warn(`${fromInfo.getOriginName()} ${fromInfo.getFrom()} file not found: ${(_b = (_a = fromInfo.getDeclaringArkFile()) === null || _a === void 0 ? void 0 : _a.getFileSignature()) === null || _b === void 0 ? void 0 : _b.toString()}`);
        return null;
    }
    if ((0, ArkSignature_1.fileSignatureCompare)(file.getFileSignature(), fromInfo.getDeclaringArkFile().getFileSignature())) {
        for (let exportInfo of file.getExportInfos()) {
            if (exportInfo.getOriginName() === fromInfo.getOriginName()) {
                exportInfo.setArkExport(file.getDefaultClass());
                return exportInfo;
            }
        }
        return null;
    }
    let exportInfo = findExportInfoInfile(fromInfo, file) || null;
    if (exportInfo === null) {
        logger.warn('export info not found, ' + fromInfo.getFrom() + ' in file: ' + fromInfo.getDeclaringArkFile().getFileSignature().toString());
        return null;
    }
    const arkExport = findArkExport(exportInfo);
    exportInfo.setArkExport(arkExport);
    if (arkExport) {
        exportInfo.setExportClauseType(arkExport.getExportType());
    }
    return exportInfo;
}
exports.findExportInfo = findExportInfo;
function findArkExport(exportInfo) {
    var _a, _b, _c, _d, _e, _f;
    if (!exportInfo) {
        return null;
    }
    let arkExport = exportInfo.getArkExport();
    if (arkExport || arkExport === null) {
        return arkExport;
    }
    if (!exportInfo.getFrom()) {
        const name = exportInfo.getOriginName();
        const defaultClass = (_b = (_a = exportInfo.getDeclaringArkNamespace()) === null || _a === void 0 ? void 0 : _a.getDefaultClass()) !== null && _b !== void 0 ? _b : exportInfo.getDeclaringArkFile().getDefaultClass();
        if (exportInfo.getExportClauseType() === ArkExport_1.ExportType.LOCAL) {
            arkExport = (_d = (_c = defaultClass.getDefaultArkMethod()) === null || _c === void 0 ? void 0 : _c.getBody()) === null || _d === void 0 ? void 0 : _d.getExportLocalByName(name);
        }
        else if (exportInfo.getExportClauseType() === ArkExport_1.ExportType.TYPE) {
            arkExport = (_f = (_e = defaultClass.getDefaultArkMethod()) === null || _e === void 0 ? void 0 : _e.getBody()) === null || _f === void 0 ? void 0 : _f.getAliasTypeByName(name);
        }
        else {
            arkExport = findArkExportInFile(name, exportInfo.getDeclaringArkFile());
        }
    }
    else if (exportInfo.getExportClauseType() === ArkExport_1.ExportType.UNKNOWN) {
        const result = findExportInfo(exportInfo);
        if (result) {
            arkExport = result.getArkExport() || null;
        }
    }
    if (arkExport) {
        exportInfo.setArkExport(arkExport);
    }
    else {
        const file = exportInfo.getDeclaringArkFile().getFileSignature().toString();
        logger.warn(`${exportInfo.getExportClauseName()} get arkExport fail from ${exportInfo.getFrom()} at ${file}`);
    }
    return arkExport || null;
}
exports.findArkExport = findArkExport;
function findArkExportInFile(name, declaringArkFile) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let arkExport = (_f = (_e = (_d = (_a = declaringArkFile.getNamespaceWithName(name)) !== null && _a !== void 0 ? _a : (_c = (_b = declaringArkFile.getDefaultClass().getDefaultArkMethod()) === null || _b === void 0 ? void 0 : _b.getBody()) === null || _c === void 0 ? void 0 : _c.getAliasTypeByName(name)) !== null && _d !== void 0 ? _d : declaringArkFile.getClassWithName(name)) !== null && _e !== void 0 ? _e : declaringArkFile.getDefaultClass().getMethodWithName(name)) !== null && _f !== void 0 ? _f : (_h = (_g = declaringArkFile.getDefaultClass().getDefaultArkMethod()) === null || _g === void 0 ? void 0 : _g.getBody()) === null || _h === void 0 ? void 0 : _h.getExportLocalByName(name);
    if (!arkExport) {
        const importInfo = declaringArkFile.getImportInfoBy(name);
        if (importInfo) {
            const result = findExportInfo(importInfo);
            if (result) {
                arkExport = result.getArkExport();
            }
        }
    }
    return arkExport || null;
}
exports.findArkExportInFile = findArkExportInFile;
function processSdkPath(sdk, formPath) {
    let originPath = path_1.default.join(sdk.path, formPath);
    if (FileUtils_1.FileUtils.isDirectory(originPath)) {
        formPath = path_1.default.join(formPath, FileUtils_1.FileUtils.getIndexFileName(originPath));
    }
    return `${formPath}`;
}
function getArkFileFromScene(im, originPath) {
    if (FileUtils_1.FileUtils.isDirectory(originPath)) {
        originPath = path_1.default.join(originPath, FileUtils_1.FileUtils.getIndexFileName(originPath));
    }
    const fileName = path_1.default.relative(im.getDeclaringArkFile().getProjectDir(), originPath);
    const scene = im.getDeclaringArkFile().getScene();
    if (/\.e?ts$/.test(originPath)) {
        const fromSignature = new ArkSignature_1.FileSignature(im.getDeclaringArkFile().getProjectName(), fileName);
        return scene.getFile(fromSignature);
    }
    const projectName = im.getDeclaringArkFile().getProjectName();
    return getArkFileFormMap(projectName, fileName, scene);
}
function getArkFileFormMap(projectName, filePath, scene) {
    if (/\.e?ts$/.test(filePath)) {
        return scene.getFile(new ArkSignature_1.FileSignature(projectName, filePath));
    }
    const fileSuffixArray = scene.getOptions().supportFileExts;
    if (!fileSuffixArray) {
        return null;
    }
    for (const suffix of fileSuffixArray) {
        const arkFile = scene.getFile(new ArkSignature_1.FileSignature(projectName, filePath + suffix));
        if (arkFile) {
            return arkFile;
        }
    }
    return null;
}
function findExportInfoInfile(fromInfo, file) {
    const exportName = fromInfo.isDefault() ? TSConst_1.DEFAULT : fromInfo.getOriginName();
    let exportInfo = file.getExportInfoBy(exportName);
    if (exportInfo) {
        return exportInfo;
    }
    if (exportName === TSConst_1.DEFAULT) {
        exportInfo = file.getExportInfos().find(p => p.isDefault());
        if (exportInfo) {
            file.addExportInfo(exportInfo, TSConst_1.DEFAULT);
            return exportInfo;
        }
    }
    if (fromInfo.getOriginName() === TSConst_1.ALL) {
        exportInfo = (0, ArkExportBuilder_1.buildDefaultExportInfo)(fromInfo, file);
        file.addExportInfo(exportInfo, TSConst_1.ALL);
    }
    else if (/\.d\.e?ts$/.test(file.getName())) {
        let declare = exportName === TSConst_1.DEFAULT ? undefined : findArkExportInFile(fromInfo.getOriginName(), file) || undefined;
        exportInfo = (0, ArkExportBuilder_1.buildDefaultExportInfo)(fromInfo, file, declare);
    }
    return exportInfo;
}
function initModulePathMap(ohPkgContentMap) {
    if (moduleMap) {
        moduleMap.clear();
    }
    moduleMap = FileUtils_1.FileUtils.generateModuleMap(ohPkgContentMap);
}
exports.initModulePathMap = initModulePathMap;
function getArkFileFromOtherModule(fromInfo) {
    if (!moduleMap || moduleMap.size === 0) {
        return undefined;
    }
    const from = fromInfo.getFrom();
    let index;
    let file;
    let modulePath;
    //find file by given from like '@ohos/module/src/xxx' '@ohos/module/index'
    if ((index = from.indexOf('src')) > 0 || (index = from.indexOf('Index')) > 0 || (index = from.indexOf('index')) > 0) {
        modulePath = moduleMap.get(from.substring(0, index).replace(/\/*$/, ''));
        file = findFileInModule(fromInfo, modulePath, from.substring(index));
    }
    if (file) {
        return file;
    }
    modulePath = modulePath !== null && modulePath !== void 0 ? modulePath : moduleMap.get(from);
    if (!modulePath) {
        return file;
    }
    //find file in module json main path
    if (modulePath.main) {
        file = getArkFileFromScene(fromInfo, modulePath.main);
    }
    //find file in module path Index.ts
    if (!file && FileUtils_1.FileUtils.isDirectory(modulePath.path)) {
        file = findFileInModule(fromInfo, modulePath, FileUtils_1.FileUtils.getIndexFileName(modulePath.path));
    }
    //find file in module path/src/main/ets/TsIndex.ts
    if (!file) {
        file = findFileInModule(fromInfo, modulePath, '/src/main/ets/TsIndex.ts');
    }
    return file;
}
function findFileInModule(fromInfo, modulePath, contentPath) {
    if (!modulePath) {
        return undefined;
    }
    const originPath = path_1.default.join(modulePath.path, contentPath);
    let file;
    if (originPath !== modulePath.main) {
        file = getArkFileFromScene(fromInfo, originPath);
    }
    if (file && findExportInfoInfile(fromInfo, file)) {
        return file;
    }
    return undefined;
}
